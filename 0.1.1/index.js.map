{"version":3,"file":"index.js","mappings":"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","sources":["webpack://FlatBinaryDecoder/webpack/universalModuleDefinition","webpack://FlatBinaryDecoder/webpack/bootstrap","webpack://FlatBinaryDecoder/webpack/runtime/define property getters","webpack://FlatBinaryDecoder/webpack/runtime/hasOwnProperty shorthand","webpack://FlatBinaryDecoder/webpack/runtime/make namespace object","webpack://FlatBinaryDecoder/./node_modules/cbor-x/decode.js","webpack://FlatBinaryDecoder/./node_modules/cbor-x/encode.js","webpack://FlatBinaryDecoder/./src/flat/flat.ts","webpack://FlatBinaryDecoder/./src/uplc/utils.ts","webpack://FlatBinaryDecoder/./src/uplc/instances.ts","webpack://FlatBinaryDecoder/./src/uplc/terms.ts","webpack://FlatBinaryDecoder/./src/uplc/codecs.ts","webpack://FlatBinaryDecoder/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FlatBinaryDecoder\"] = factory();\n\telse\n\t\troot[\"FlatBinaryDecoder\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n","export abstract class Flat<T> {\n  public abstract decode(decoder: DecoderState): T;\n}\n\nclass Natural {\n  public n: bigint;\n\n  constructor(n: bigint) {\n    this.n = n;\n  }\n}\n\nexport class FlatNatural extends Flat<Natural> {\n  private static readonly instance = new FlatNatural();\n\n  public static getInstance() {\n    return FlatNatural.instance;\n  }\n  public decode(decoder: DecoderState): Natural {\n    let w = decoder.bits8(8);\n    let r = BigInt(0);\n    let shl = 0;\n\n    while ((w & 0x80) !== 0) {\n      r = r | (BigInt(w & 0x7f) << BigInt(shl));\n      shl += 7;\n      w = decoder.bits8(8);\n    }\n\n    r = r | (BigInt(w & 0x7f) << BigInt(shl));\n    return new Natural(r);\n  }\n}\n\nexport class FlatBigInt extends Flat<bigint> {\n  private static readonly instance = new FlatBigInt();\n\n  public static getInstance() {\n    return FlatBigInt.instance;\n  }\n  public decode(decoder: DecoderState): bigint {\n    let w = decoder.bits8(8);\n    let r = BigInt(0);\n    let shl = 0;\n\n    while ((w & 0x80) !== 0) {\n      r = r | (BigInt(w & 0x7f) << BigInt(shl));\n      shl += 7;\n      w = decoder.bits8(8);\n    }\n\n    r = r | (BigInt(w & 0x7f) << BigInt(shl));\n    return zagZig(r);\n  }\n}\n\nexport class FlatArrayByte extends Flat<Int8Array> {\n  private static readonly instance = new FlatArrayByte();\n\n  public static getInstance() {\n    return FlatArrayByte.instance;\n  }\n  public decode(decoder: DecoderState): Int8Array {\n    decoder.filler();\n    let numElems = decoder.buffer[decoder.currPtr] & 0xff;\n    let decoderOffset = numElems + 1;\n    let size = numElems;\n\n    // Calculate size\n    while (numElems === 255) {\n      numElems = decoder.buffer[decoder.currPtr + decoderOffset] & 0xff;\n      size += numElems;\n      decoderOffset += numElems + 1;\n    }\n\n    const result = new Int8Array(size);\n    numElems = decoder.buffer[decoder.currPtr] & 0xff;\n    decoder.currPtr += 1;\n    let resultOffset = 0;\n\n    while (numElems > 0) {\n      result.set(\n        decoder.buffer.subarray(decoder.currPtr, decoder.currPtr + numElems),\n        resultOffset\n      );\n\n      decoder.currPtr += numElems;\n      resultOffset += numElems;\n\n      numElems = decoder.buffer[decoder.currPtr] & 0xff;\n      decoder.currPtr += 1;\n    }\n\n    return result;\n  }\n}\n\nexport class FlatString extends Flat<string> {\n  private static readonly instance = new FlatString();\n\n  public static getInstance() {\n    return FlatString.instance;\n  }\n  public decode(decoder: DecoderState): string {\n    const bytes = FlatArrayByte.getInstance().decode(decoder);\n    return new TextDecoder('UTF-8').decode(bytes);\n  }\n}\n\nexport class FlatBoolean extends Flat<boolean> {\n  private static readonly instance = new FlatBoolean();\n\n  public static getInstance() {\n    return FlatBoolean.instance;\n  }\n  public decode(decoder: DecoderState): boolean {\n    const decoded = decoder.bits8(1);\n    return decoded === 1;\n  }\n}\n\nexport class FlatUnit extends Flat<string> {\n  private static readonly instance = new FlatUnit();\n\n  public static getInstance() {\n    return FlatUnit.instance;\n  }\n  public decode(decoder: DecoderState): string {\n    return decoder ? '()' : '';\n  }\n}\nexport class FlatData extends Flat<Int8Array> {\n  private static readonly instance = new FlatData();\n\n  public static getInstance() {\n    return FlatData.instance;\n  }\n\n  public decode(decoder: DecoderState): Int8Array {\n    const bytes = FlatArrayByte.getInstance().decode(decoder);\n    return bytes;\n  }\n}\n\nexport const zagZig = (u: bigint): bigint => {\n  return (u >> BigInt('1')) ^ -(u & BigInt('1'));\n};\n\nexport class DecoderState {\n  /** The buffer that contains a sequence of flat-encoded values */\n  public buffer: Int8Array;\n  /** Pointer to the current byte being decoded (0..buffer.byteLength-1) */\n  public currPtr: number = 0;\n  /** Number of already decoded bits in the current byte (0..7) */\n  public usedBits: number = 0;\n\n  constructor(buffer: Int8Array) {\n    this.buffer = buffer;\n  }\n\n  toString(): string {\n    return `DecoderState(currPtr:${this.currPtr}, usedBits:${\n      this.usedBits\n    }, buffer:[${Array.from(this.buffer)\n      .map((byte) => byte.toString())\n      .join(', ')}])`;\n  }\n\n  /** Decode up to 8 bits\n   * @param numBits\n   *   the number of bits to decode (0..8)\n   */\n  bits8(numBits: number): number {\n    if (numBits < 0 || numBits > 8) {\n      throw new Error('Decoder.bits8: incorrect value of numBits ' + numBits);\n    }\n\n    this.ensureBits(numBits);\n    // usedBits=1 numBits=8 unusedBits=7 leadingZeros=0 unusedBits+leadingZeros=7\n    const unusedBits = 8 - this.usedBits;\n    const leadingZeros = 8 - numBits;\n    let r =\n      ((this.buffer[this.currPtr] << this.usedBits) & 255) >>> leadingZeros;\n\n    if (numBits > unusedBits) {\n      const nextByte: number = this.buffer[this.currPtr + 1];\n      const lowerBits = (nextByte & 255) >>> (unusedBits + leadingZeros);\n      r = r | lowerBits;\n    }\n\n    this.dropBits(numBits);\n\n    return r & 255;\n  }\n\n  filler(): void {\n    while (this.bits8(1) === 0) {\n      /* empty */\n    }\n  }\n\n  private ensureBits(requiredBits: number): void {\n    if (requiredBits > this.availableBits()) {\n      throw new Error(\n        'DecoderState: Not enough data available: ' + this.toString()\n      );\n    }\n  }\n\n  private availableBits(): number {\n    return 8 * this.availableBytes() - this.usedBits;\n  }\n\n  // Available bytes, ignoring used bits\n  private availableBytes(): number {\n    return this.buffer.length - this.currPtr;\n  }\n\n  private dropBits(numBits: number): void {\n    const totUsed = numBits + this.usedBits;\n    this.usedBits = totUsed % 8;\n    this.currPtr += Math.floor(totUsed / 8);\n  }\n}\n\nexport class ListFlat<T> {\n  public decoder: Flat<T>;\n\n  constructor(flat: Flat<T>) {\n    this.decoder = flat;\n  }\n  public decode(decode: DecoderState): T[] {\n    const result: T[] = [];\n    while (decode.bits8(1) === 1) {\n      const a = this.decoder.decode(decode);\n      result.push(a as T);\n    }\n    return result;\n  }\n}\n","import {\n  ByteString,\n  DefaultUni,\n  Integer,\n  String,\n  Unit,\n  Bool,\n  ProtoPair,\n  Data,\n  ProtoList,\n} from './instances';\n\nexport enum ApplyType {\n  ProtoList,\n  ProtoPair,\n}\n\nexport class Constant {\n  public static fromValue(tpe: DefaultUni, decoded: unknown) {\n    return new Constant(tpe, decoded);\n  }\n  public tpe?: DefaultUni;\n  public value?: unknown;\n\n  constructor(tpe: DefaultUni, value: unknown) {\n    this.tpe = tpe;\n    this.value = value;\n  }\n\n  public prettyValue(c: DefaultUni): string {\n    if (c instanceof Integer) {\n      return `${this.value}`;\n    }\n    if (c instanceof ByteString) {\n      return `#${bytesToHex(this.value as Int8Array)}`;\n    }\n    if (c instanceof String) {\n      return `\"${this.value}\"`;\n    }\n    if (c instanceof Unit) {\n      return `${this.value}`;\n    }\n    if (c instanceof Bool) {\n      return this.value ? 'True' : 'False';\n    }\n    if (c instanceof ProtoList) {\n      return `[${(this.value as Array<Constant>)\n        .map((v) => this.prettyValue(v))\n        .join(', ')}]`;\n    }\n    if (c instanceof ProtoPair) {\n      return `${this.value}`;\n    }\n    if (c instanceof Data) {\n      return `#${bytesToHex(this.value as Int8Array)}`;\n    }\n    return '';\n  }\n\n  public pretty(): string {\n    if (!this.tpe) return '';\n    return `${DefaultUni.pretty(this.tpe)} ${this.prettyValue(this.tpe)}`;\n  }\n}\n\nexport const DefaultFun = {\n  // Integers\n  AddInteger: 'addInteger',\n  SubtractInteger: 'subtractInteger',\n  MultiplyInteger: 'multiplyInteger',\n  DivideInteger: 'divideInteger',\n  QuotientInteger: 'quotientInteger',\n  RemainderInteger: 'remainderInteger',\n  ModInteger: 'modInteger',\n  EqualsInteger: 'equalsInteger',\n  LessThanInteger: 'lessThanInteger',\n  LessThanEqualsInteger: 'lessThanEqualsInteger',\n  // Bytestrings\n  AppendByteString: 'appendByteString',\n  ConsByteString: 'consByteString',\n  SliceByteString: 'sliceByteString',\n  LengthOfByteString: 'lengthOfByteString',\n  IndexByteString: 'indexByteString',\n  EqualsByteString: 'equalsByteString',\n  LessThanByteString: 'lessThanByteString',\n  LessThanEqualsByteString: 'lessThanEqualsByteString',\n  // Cryptography and hashes\n  Sha2_256: 'sha2_256',\n  Sha3_256: 'sha3_256',\n  Blake2b_256: 'blake2b_256',\n  VerifyEd25519Signature: 'verifyEd25519Signature',\n  VerifyEcdsaSecp256k1Signature: 'verifyEcdsaSecp256k1Signature',\n  VerifySchnorrSecp256k1Signature: 'verifySchnorrSecp256k1Signature',\n  // Strings\n  AppendString: 'appendString',\n  EqualsString: 'equalsString',\n  EncodeUtf8: 'encodeUtf8',\n  DecodeUtf8: 'decodeUtf8',\n  // Bool\n  IfThenElse: 'ifThenElse',\n  // Unit\n  ChooseUnit: 'chooseUnit',\n  // Tracing\n  Trace: 'trace',\n  // Pairs\n  FstPair: 'fstPair',\n  SndPair: 'sndPair',\n  // Lists\n  ChooseList: 'chooseList',\n  MkCons: 'mkCons',\n  HeadList: 'headList',\n  TailList: 'tailList',\n  NullList: 'nullList',\n  // Data\n  ChooseData: 'chooseData',\n  ConstrData: 'constrData',\n  MapData: 'mapData',\n  ListData: 'listData',\n  IData: 'iData',\n  BData: 'bData',\n  UnConstrData: 'unConstrData',\n  UnMapData: 'unMapData',\n  UnListData: 'unListData',\n  UnIData: 'unIData',\n  UnBData: 'unBData',\n  EqualsData: 'equalsData',\n  SerialiseData: 'serialiseData',\n  // Misc monomorphized constructors\n  MkPairData: 'mkPairData',\n  MkNilData: 'mkNilData',\n  MkNilPairData: 'mkNilPairData',\n};\n\nexport const hexToUint8Array = (hexString: string) => {\n  // Remove the leading \"0x\" if present\n  hexString = hexString.startsWith('0x') ? hexString.slice(2) : hexString;\n\n  // Ensure the hex string has an even length\n  if (hexString.length % 2 !== 0) {\n    throw new Error('Invalid hex string');\n  }\n\n  // Create a Uint8Array\n  const uint8Array = new Uint8Array(hexString.length / 2);\n\n  // Iterate over the hex string, convert each pair of characters to a byte, and store it in the Uint8Array\n  for (let i = 0; i < hexString.length; i += 2) {\n    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n\n  return uint8Array;\n};\n\nexport const toInt8Array = (uInt8Array: Uint8Array) => {\n  const int8Array = new Int8Array(uInt8Array.length);\n  for (let i = 0; i < uInt8Array.length; i++) {\n    int8Array[i] = (uInt8Array[i] << 24) >> 24;\n  }\n  return int8Array;\n};\n\nexport const toUint8Array = (int8Array: Int8Array): Uint8Array => {\n  const uint8Array = new Uint8Array(int8Array.length);\n  for (let i = 0; i < int8Array.length; i++) {\n    // Chuyển đổi từ Int8 sang Uint8\n    uint8Array[i] = int8Array[i] & 0xff;\n  }\n  return uint8Array;\n};\n\nconst HEX_ARRAY: string[] = '0123456789ABCDEF'.split('');\n\nexport const bytesToHex = (bytes: Int8Array): string => {\n  const hexChars: string[] = new Array(bytes.length * 2);\n  for (let j = 0; j < bytes.length; j++) {\n    const v = bytes[j] & 0xff;\n    hexChars[j * 2] = HEX_ARRAY[v >>> 4];\n    hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0f];\n  }\n  return hexChars.join('');\n};\n\nexport const removeSpacesBetweenParentheses = (str: string): string => {\n  const result = str.replace(/\\(\\s+|\\s+\\)/g, (match) => match.trim());\n\n  // keep space beetween two text\n  return result.replace(/(\\w+)\\s+(\\w+)/g, '$1 $2');\n};\n\nconst convertSquareBracketsToParentheses = (str: string): string => {\n  return str.replace(/[\\[\\]\\n]+/g, (match) => {\n    if (match === '\\n') return ''; // Remove newlines\n    return match === '[' ? '(' : ')';\n  });\n};\n\nexport interface TreeNode {\n  id?: number;\n  text?: string;\n  data?: TreeNode[];\n}\n\nexport const parseNestedParenthesesToObject = (str: string): TreeNode => {\n  str = removeSpacesBetweenParentheses(convertSquareBracketsToParentheses(str));\n  const stack: TreeNode[] = [];\n  let current: TreeNode | undefined;\n  let autoInc = 0;\n\n  for (const char of str) {\n    if (char === '(') {\n      const newNode: TreeNode = { id: autoInc++ };\n      if (current) {\n        if (!current.data) {\n          current.data = [];\n        }\n        current.data.push(newNode);\n        current.text = current.text?.trim();\n        if (!current.text) {\n          delete current.text;\n        }\n        stack.push(current);\n      }\n      current = newNode;\n    } else if (char === ')') {\n      if (stack.length > 0) {\n        current = stack.pop();\n      }\n    } else {\n      if (!current) {\n        current = { id: autoInc++ };\n      }\n      current.text = (current.text || '') + char;\n    }\n  }\n\n  return current || {};\n};\n","import {\n  DecoderState,\n  Flat,\n  FlatArrayByte,\n  FlatBigInt,\n  FlatBoolean,\n  FlatData,\n  FlatString,\n  FlatUnit,\n  ListFlat,\n} from '../flat/flat';\nimport { Constant, DefaultFun } from './utils';\nconst CONSTANT_WIDTH = 4;\n\nexport class FlatConstant extends Flat<Constant> {\n  private static readonly instance = new FlatConstant();\n\n  public static getInstance() {\n    return FlatConstant.instance;\n  }\n  public decode(decoder: DecoderState): Constant {\n    const tags = new ListFlat<number>(ConstantTypeTagFlat.getInstance()).decode(\n      decoder\n    );\n    let tpe = decodeUni(tags)[0];\n    const uniDecoder = flatForUni(tpe);\n    const decoded = uniDecoder?.decode(decoder);\n    if (uniDecoder instanceof ListFlat) {\n      const protoList = tpe as ProtoList;\n      tpe = new ProtoList(protoList.f, protoList.arg);\n    }\n    const result = Constant.fromValue(tpe, decoded);\n\n    return result;\n  }\n}\n\nexport const flatForUni = (tpe: DefaultUni): Flat<unknown> | undefined => {\n  if (tpe instanceof Integer) {\n    return FlatBigInt.getInstance();\n  }\n  if (tpe instanceof ByteString) {\n    return FlatArrayByte.getInstance();\n  }\n  if (tpe instanceof String) {\n    return FlatString.getInstance();\n  }\n  if (tpe instanceof Unit) {\n    return FlatUnit.getInstance();\n  }\n  if (tpe instanceof Bool) {\n    return FlatBoolean.getInstance();\n  }\n  if (tpe instanceof Data) {\n    return FlatData.getInstance();\n  }\n  if (tpe instanceof Apply && tpe.f instanceof ProtoList && tpe.arg) {\n    return new ListFlat(flatForUni(tpe.arg)!);\n  }\n\n  if (tpe instanceof Apply && tpe.f instanceof ProtoPair && tpe.arg) {\n    //TODO: Protopair will be implemented later\n  }\n};\n\nexport class ConstantTypeTagFlat extends Flat<number> {\n  private static readonly instance = new ConstantTypeTagFlat();\n\n  public static getInstance() {\n    return ConstantTypeTagFlat.instance;\n  }\n\n  public decode(decode: DecoderState): number {\n    return decode.bits8(CONSTANT_WIDTH);\n  }\n}\n\nexport class DefaultUni {\n  public static pretty(du: DefaultUni): string {\n    if (du instanceof Integer) {\n      return `integer`;\n    }\n    if (du instanceof ByteString) {\n      return `bytestring`;\n    }\n    if (du instanceof String) {\n      return `string`;\n    }\n    if (du instanceof Unit) {\n      return `unit`;\n    }\n    if (du instanceof Bool) {\n      return `bool`;\n    }\n    if (du instanceof ProtoList) {\n      return `(list ${du.arg && this.pretty(du.arg)})`;\n    }\n    if (du instanceof ProtoPair) {\n      return `(pair)`; //TODO: Implement later\n    }\n    if (du instanceof Data) {\n      return `data`;\n    }\n    return '';\n  }\n}\n\nexport class Integer extends DefaultUni {}\nexport class ByteString extends DefaultUni {}\nexport class String extends DefaultUni {}\nexport class Unit extends DefaultUni {}\nexport class Bool extends DefaultUni {}\nexport class Data extends DefaultUni {}\nexport class Apply extends DefaultUni {\n  f?: DefaultUni;\n  arg?: DefaultUni;\n\n  constructor(f?: DefaultUni, arg?: DefaultUni) {\n    super();\n    this.f = f;\n    this.arg = arg;\n  }\n}\n\nexport class ProtoList extends Apply {}\nexport class ProtoPair extends Apply {}\n\ntype UniTuple = [DefaultUni, number[]];\nfunction decodeUni(state: number[]): UniTuple {\n  switch (state[0]) {\n    case 0:\n      return [new Integer(), state.slice(1)];\n    case 1:\n      return [new ByteString(), state.slice(1)];\n    case 2:\n      return [new String(), state.slice(1)];\n    case 3:\n      return [new Unit(), state.slice(1)];\n    case 4:\n      return [new Bool(), state.slice(1)];\n    case 5:\n      return [new ProtoList(), state.slice(1)];\n    case 6:\n      return [new ProtoPair(), state.slice(1)];\n    case 7: {\n      const [uniF, tail1] = decodeUni(state.slice(1));\n      const [uniA, tail2] = decodeUni(tail1);\n      return [new Apply(uniF, uniA), tail2];\n    }\n    case 8:\n      return [new Data(), state.slice(1)];\n    default:\n      throw new Error(`Invalid uni: ${state[0]}`);\n  }\n}\n\nexport class FlatDefaultFun extends Flat<string> {\n  private static readonly instance = new FlatDefaultFun();\n\n  public static getInstance() {\n    return FlatDefaultFun.instance;\n  }\n  public decode(decode: DecoderState): string {\n    const code = decode.bits8(7);\n    switch (code) {\n      case 0:\n        return DefaultFun.AddInteger;\n      case 1:\n        return DefaultFun.SubtractInteger;\n      case 2:\n        return DefaultFun.MultiplyInteger;\n      case 3:\n        return DefaultFun.DivideInteger;\n      case 4:\n        return DefaultFun.QuotientInteger;\n      case 5:\n        return DefaultFun.RemainderInteger;\n      case 6:\n        return DefaultFun.ModInteger;\n      case 7:\n        return DefaultFun.EqualsInteger;\n      case 8:\n        return DefaultFun.LessThanInteger;\n      case 9:\n        return DefaultFun.LessThanEqualsInteger;\n      case 10:\n        return DefaultFun.AppendByteString;\n      case 11:\n        return DefaultFun.ConsByteString;\n      case 12:\n        return DefaultFun.SliceByteString;\n      case 13:\n        return DefaultFun.LengthOfByteString;\n      case 14:\n        return DefaultFun.IndexByteString;\n      case 15:\n        return DefaultFun.EqualsByteString;\n      case 16:\n        return DefaultFun.LessThanByteString;\n      case 17:\n        return DefaultFun.LessThanEqualsByteString;\n      case 18:\n        return DefaultFun.Sha2_256;\n      case 19:\n        return DefaultFun.Sha3_256;\n      case 20:\n        return DefaultFun.Blake2b_256;\n      case 21:\n        return DefaultFun.VerifyEd25519Signature;\n      case 22:\n        return DefaultFun.AppendString;\n      case 23:\n        return DefaultFun.EqualsString;\n      case 24:\n        return DefaultFun.EncodeUtf8;\n      case 25:\n        return DefaultFun.DecodeUtf8;\n      case 26:\n        return DefaultFun.IfThenElse;\n      case 27:\n        return DefaultFun.ChooseUnit;\n      case 28:\n        return DefaultFun.Trace;\n      case 29:\n        return DefaultFun.FstPair;\n      case 30:\n        return DefaultFun.SndPair;\n      case 31:\n        return DefaultFun.ChooseList;\n      case 32:\n        return DefaultFun.MkCons;\n      case 33:\n        return DefaultFun.HeadList;\n      case 34:\n        return DefaultFun.TailList;\n      case 35:\n        return DefaultFun.NullList;\n      case 36:\n        return DefaultFun.ChooseData;\n      case 37:\n        return DefaultFun.ConstrData;\n      case 38:\n        return DefaultFun.MapData;\n      case 39:\n        return DefaultFun.ListData;\n      case 40:\n        return DefaultFun.IData;\n      case 41:\n        return DefaultFun.BData;\n      case 42:\n        return DefaultFun.UnConstrData;\n      case 43:\n        return DefaultFun.UnMapData;\n      case 44:\n        return DefaultFun.UnListData;\n      case 45:\n        return DefaultFun.UnIData;\n      case 46:\n        return DefaultFun.UnBData;\n      case 47:\n        return DefaultFun.EqualsData;\n      case 48:\n        return DefaultFun.MkPairData;\n      case 49:\n        return DefaultFun.MkNilData;\n      case 50:\n        return DefaultFun.MkNilPairData;\n      case 51:\n        return DefaultFun.SerialiseData;\n      case 52:\n        return DefaultFun.VerifyEcdsaSecp256k1Signature;\n      case 53:\n        return DefaultFun.VerifySchnorrSecp256k1Signature;\n      default:\n        throw new Error(`Invalid builtin function code: ${code}`);\n    }\n  }\n}\n","import { Constant } from './utils';\nimport { DecoderState, FlatNatural } from '../flat/flat';\nimport { FlatConstant, FlatDefaultFun } from './instances';\n\nexport const fromDeBruijnTerm = (term: Term): Term => {\n  let idx = 0;\n  const go = (term: Term, env: Array<string>): Term => {\n    switch (term.type) {\n      case TermType.Var: {\n        const binderName = env[term.name!.index - 1];\n        const name = new NamedDeBruijn(binderName, term.name?.index);\n        return Term.Var(name);\n      }\n      case TermType.LamAbs: {\n        const binderName: string = `i_${idx}`;\n        idx += 1;\n        return Term.LamAbs(binderName, go(term.term!, [binderName, ...env]));\n      }\n      case TermType.Apply: {\n        const { f, arg } = term;\n        return Term.Apply(go(f!, env), go(arg!, env));\n      }\n      case TermType.Force: {\n        return Term.Force(go(term.term!, env));\n      }\n      case TermType.Delay: {\n        return Term.Delay(go(term.term!, env));\n      }\n      case TermType.Const: {\n        return term;\n      }\n      case TermType.Builtin: {\n        return term;\n      }\n      case TermType.Error: {\n        return term;\n      }\n      default:\n        throw new Error('not found term type');\n    }\n  };\n  return go(term, []);\n};\n\nexport class NamedDeBruijn {\n  name: string;\n  index: number;\n\n  constructor(name: string, index: number = 0) {\n    if (index < 0) {\n      throw new Error('Index must be non-negative.');\n    }\n\n    this.name = name;\n    this.index = index;\n  }\n\n  toString(): string {\n    if (this.index === 0) {\n      return `NamedDeBruijn(\"${this.name}\")`;\n    } else {\n      return `NamedDeBruijn(\"${this.name}\", ${this.index})`;\n    }\n  }\n}\n\nexport enum TermType {\n  Var,\n  LamAbs,\n  Apply,\n  Force,\n  Delay,\n  Const,\n  Builtin,\n  Error,\n}\n\nexport class Term {\n  type?: TermType;\n  name?: NamedDeBruijn;\n  term?: Term;\n  f?: Term;\n  arg?: Term;\n  const?: Constant;\n  bn?: string;\n\n  static Var(name: NamedDeBruijn): Term {\n    const vars = new Term();\n    vars.type = TermType.Var;\n    vars.name = name;\n    return vars;\n  }\n\n  static LamAbs(name: string, term: Term): Term {\n    const lamAbsTerm = new Term();\n    lamAbsTerm.type = TermType.LamAbs;\n    lamAbsTerm.name = new NamedDeBruijn(name);\n    lamAbsTerm.term = term;\n    return lamAbsTerm;\n  }\n\n  static Apply(f: Term, arg: Term): Term {\n    const applyTerm = new Term();\n    applyTerm.type = TermType.Apply;\n    applyTerm.f = f;\n    applyTerm.arg = arg;\n    return applyTerm;\n  }\n\n  static Force(term: Term): Term {\n    const forceTerm = new Term();\n    forceTerm.type = TermType.Force;\n    forceTerm.term = term;\n    return forceTerm;\n  }\n\n  static Delay(term: Term): Term {\n    const delayTerm = new Term();\n    delayTerm.type = TermType.Delay;\n    delayTerm.term = term;\n    return delayTerm;\n  }\n\n  static Const(constant: Constant): Term {\n    const constTerm = new Term();\n    constTerm.type = TermType.Const;\n    constTerm.const = constant;\n    return constTerm;\n  }\n\n  static Builtin(defaultFun: string): Term {\n    const builtinTerm = new Term();\n    builtinTerm.type = TermType.Builtin;\n    builtinTerm.bn = defaultFun;\n    return builtinTerm;\n  }\n\n  static Error(): Term {\n    const errorTerm = new Term();\n    errorTerm.type = TermType.Error;\n    return errorTerm;\n  }\n\n  public pretty(): string | undefined {\n    switch (this.type) {\n      case TermType.Var: {\n        const name = this.name ? this.name.name : '';\n        return name;\n      }\n      case TermType.LamAbs: {\n        return `  (lam ${this.name?.name} ${this.term?.pretty()})`;\n      }\n      case TermType.Apply: {\n        return `[ ${this.f?.pretty()} ${this.arg?.pretty()} ]`;\n      }\n      case TermType.Force: {\n        return `(force ${this.term?.pretty()})`;\n      }\n      case TermType.Delay: {\n        return `(delay ${this.term?.pretty()})`;\n      }\n      case TermType.Const: {\n        return `(con ${this.const?.pretty()})`;\n      }\n      case TermType.Builtin: {\n        return `(builtin ${this.bn})`;\n      }\n      case TermType.Error: {\n        return `(error)`;\n      }\n    }\n  }\n}\n\nexport type Version = {\n  major: number;\n  minor: number;\n  patch: number;\n};\n\nexport class DeBruijnedProgram {\n  version: Version;\n  term: Term;\n\n  constructor(version: Version, term: Term) {\n    this.version = version;\n    this.term = term;\n  }\n\n  public pretty() {\n    const { major, minor, patch } = this.version;\n    return `(program\\n  ${major}.${minor}.${patch}\\n${this.term.pretty()}\\n)`;\n  }\n}\n\nexport const termTagWidth = 4;\n\nexport class FlatDeBruijnedProgram {\n  public static decode(decoder: DecoderState): DeBruijnedProgram {\n    const v1 = Number(FlatNatural.getInstance().decode(decoder).n);\n    const v2 = Number(FlatNatural.getInstance().decode(decoder).n);\n    const v3 = Number(FlatNatural.getInstance().decode(decoder).n);\n    const term = FlatTerm.decode(decoder);\n    return new DeBruijnedProgram(\n      { major: v1, minor: v2, patch: v3 } as Version,\n      term\n    );\n  }\n}\nexport class FlatTerm {\n  public static decode(decoder: DecoderState): Term {\n    const tag = decoder.bits8(termTagWidth);\n    switch (tag) {\n      case 0: {\n        const index = Number(FlatNatural.getInstance().decode(decoder).n);\n        const name: string = `i_${index}`;\n        return Term.Var(new NamedDeBruijn(name, index));\n      }\n      case 1: {\n        const term = FlatTerm.decode(decoder);\n        return Term.Delay(term);\n      }\n      case 2: {\n        const term = FlatTerm.decode(decoder);\n        return Term.LamAbs('i_0', term);\n      }\n      case 3: {\n        const f = FlatTerm.decode(decoder);\n        const arg = FlatTerm.decode(decoder);\n        return Term.Apply(f, arg);\n      }\n      case 4:\n        return Term.Const(FlatConstant.getInstance().decode(decoder));\n      case 5: {\n        const term = FlatTerm.decode(decoder);\n        return Term.Force(term);\n      }\n      case 6:\n        return Term.Error();\n      case 7:\n        return Term.Builtin(FlatDefaultFun.getInstance().decode(decoder));\n      default:\n        throw new Error(`Not found tag: ${tag}`);\n    }\n  }\n}\n","import { DecoderState } from '../flat/flat';\nimport { DeBruijnedProgram, FlatDeBruijnedProgram } from './terms';\n\nexport class ProgramFlatCodec {\n  public static decodeFlat(encoded: Int8Array): DeBruijnedProgram {\n    const decoderState = new DecoderState(encoded);\n    return FlatDeBruijnedProgram.decode(decoderState);\n  }\n}\n","import { decode } from 'cbor-x';\nimport { ProgramFlatCodec } from './src/uplc/codecs';\nimport { DeBruijnedProgram, fromDeBruijnTerm } from './src/uplc/terms';\nimport {\n  hexToUint8Array,\n  parseNestedParenthesesToObject,\n  toInt8Array,\n} from './src/uplc/utils';\n\nconst getDeBruijnedProgram = (\n  deserializeContract: string\n): DeBruijnedProgram => {\n  const contractByteArray = hexToUint8Array(deserializeContract);\n  const scriptFlat = decode(contractByteArray);\n  const decoder = toInt8Array(scriptFlat);\n\n  const program = ProgramFlatCodec.decodeFlat(decoder);\n  const namedTerm = fromDeBruijnTerm(program.term);\n  const applied = new DeBruijnedProgram(program.version, namedTerm);\n  return applied;\n};\n\nexport const decodeFlatUplc = (deserializeContract: string): string => {\n  const applied = getDeBruijnedProgram(deserializeContract);\n  return applied.pretty();\n};\n\nexport const decodeFlatUplcToObject = (deserializeContract: string) => {\n  const applied = getDeBruijnedProgram(deserializeContract);\n  const termPretty = applied.term.pretty() || '';\n  const decodedObject = {\n    version: applied.version,\n    data: parseNestedParenthesesToObject(termPretty),\n  };\n  return decodedObject;\n};\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","decoder","src","srcEnd","TextDecoder","error","position","EMPTY_ARRAY","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","STOP_CODE","currentStructures","srcString","bundledStrings","referenceMap","packedValues","dataView","restoreMapsAsObject","strings","stringPosition","currentDecoder","srcStringStart","srcStringEnd","currentExtensions","currentExtensionRanges","defaultOptions","useRecords","mapsAsObjects","sequentialMode","inlineObjectReadThreshold","Function","Infinity","constructor","options","keyMap","_keyMap","undefined","getStructures","getShared","structures","uninitialized","mapKey","Map","k","v","entries","set","assign","decodeKey","encodeKey","encodeKeys","rec","map","decodeKeys","name","_mapKey","res","forEach","safeKey","has","mapDecode","source","end","decode","r","saveState","clearSource","length","DataView","buffer","byteOffset","byteLength","Uint8Array","Error","sharedValues","pack","Array","maxPrivatePackedValues","concat","checkedRead","decodeMultiple","values","lastPosition","size","defaultDecoder","push","result","read","postBundlePosition","incomplete","RangeError","message","startsWith","token","majorType","byte0","byte1","exponent","NaN","abs","u8Array","f32Array","getFloat16","getUint16","getFloat32","useFloat32","multiplier","mult10","getUint32","getFloat64","int64AsNumber","getBigUint64","array","i","join","Buffer","object","copyBuffers","slice","subarray","string","shortStringInJS","start","bytes","byte","fromCharCode","apply","String","longStringInJS","readFixedString","structure","createStructureReader","readJustLength","id","recordDefinition","bundlePosition","bundleLength","dataPosition","readStringJS","position0","position1","readBundleExt","loadShared","extension","handlesRead","input","Tag","packedValue","getPackedValues","isNaN","validName","slowReads","compiledReader","propertyCount","next","test","JSON","stringify","units","byte2","byte3","unit","a","b","c","d","e","f","g","h","j","l","m","n","Float32Array","tag","dateString","Date","epochSec","Math","round","BigInt","fraction","exp","log","existingStructure","isShared","restoreStructures","data","glbl","RegExp","packedTable","newPackedValues","prefixes","suffixes","combine","target","refEntry","targetProperties","used","Set","version","isLittleEndianMachine","Uint16Array","typedArrays","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float64Array","typedArrayTags","registerTypedArray","TypedArray","bytesPerElement","dvMethod","BYTES_PER_ELEMENT","littleEndian","sizeShift","dv","elements","ta","method","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","floor","textEncoder","extensions","extensionClasses","TextEncoder","globalThis","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","throwOnIterable","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","writeEntityLength","majorValue","setUint32","SharedData","writeArrayHeader","BlobConstructor","Blob","isBlob","findRepetitiveStrings","objectMap","maxValues","packedStatus","count","samplingPackedValues","status","includeKeys","encoder","console","typedArrayEncoder","encode","typedArray","offset","from","writeBuffer","makeRoom","writeBundles","writeStrings","ArrayBuffer","date","seconds","getTime","useTimestamp32","getMilliseconds","setFloat64","regex","flags","getTag","arrayBuffer","tagUint8Array","sharedStructures","valuesArray","packedObjectMap","create","sharedPackedObjectMap","definitions","unshift","defaultEncoder","hasSharedUpdate","super","encodeUtf8","utf8Write","maxBytes","encodeInto","written","hasSharedStructures","saveStructures","maxSharedStructures","isSequential","sequential","saveShared","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","mapEncode","encodeOptions","_mapped","REUSE_BUFFER_MODE","useSelfDescribedHeader","structuredClone","bundleStrings","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","THROW_ON_ITERABLE","idsToInsert","serialized","distanceToMove","lastEnd","sort","referee","references","pop","copyWithin","insertIds","returnBuffer","updateSharedData","RESET_BUFFER_MODE","findCommonStringsToPack","threshold","type","packedPosition","headerSize","strLength","extStart","twoByte","c1","c2","strPosition","charCodeAt","alwaysUseFloat","xShifted","setFloat32","setUint16","writeObject","useTag259ForMaps","entryValue","iterator","iteratorNotHandled","entry","asyncIterator","useToJSON","toJSON","json","setBigUint64","largeBigIntToFloat","Number","variableMapSize","vals","safePrototype","objectOffset","parentRecordId","newTransitions","recordId","__keys__","shift","newSize","min","max","newBuffer","copy","chunkThreshold","continuedChunkThreshold","encodeObjectAsIterable","iterateProperties","finalIterable","tryEncode","element","restartEncoding","restart","startEncoding","encodeIterable","async","encodeObjectAsAsyncIterable","encodedValue","reader","stream","getReader","done","asyncValue","encodeAsIterable","encodeAsAsyncIterable","useBuffer","clearSharedData","lastVersion","structuresCopy","saveResults","existingShared","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","Flat","_createClass","_classCallCheck","Natural","FlatNatural","_Flat","_inherits","_super","_createSuper","arguments","w","bits8","shl","instance","_defineProperty","FlatBigInt","_Flat2","_super2","zagZig","FlatArrayByte","_Flat3","_super3","filler","numElems","currPtr","decoderOffset","resultOffset","FlatString","_Flat4","_super4","getInstance","FlatBoolean","_Flat5","_super5","FlatUnit","_Flat6","_super6","FlatData","_Flat7","_super7","u","DecoderState","usedBits","toString","numBits","ensureBits","unusedBits","leadingZeros","dropBits","requiredBits","availableBits","availableBytes","totUsed","ListFlat","flat","_decode","_x","Constant","tpe","decoded","_this","Integer","ByteString","bytesToHex","Unit","Bool","ProtoList","prettyValue","ProtoPair","Data","DefaultUni","pretty","HEX_ARRAY","split","hexChars","parseNestedParenthesesToObject","str","current","_step","stack","autoInc","_iterator","_createForOfIteratorHelper","replace","match","trim","removeSpacesBetweenParentheses","convertSquareBracketsToParentheses","s","char","_current$text","newNode","text","err","FlatConstant","decodeUni","ConstantTypeTagFlat","uniDecoder","flatForUni","protoList","arg","fromValue","Apply","du","_DefaultUni","_DefaultUni2","_DefaultUni3","_String","_DefaultUni4","_DefaultUni5","_DefaultUni6","_super8","_DefaultUni7","_super9","_Apply","_super10","_Apply2","_super11","state","_decodeUni2","_slicedToArray","uniF","_decodeUni4","uniA","tail2","FlatDefaultFun","_super12","code","NamedDeBruijn","index","TermType","Term","Var","LamAbs","_this$name","_this$term","term","_this$f","_this$arg","Force","_this$term2","Delay","_this$term3","Const","_this$const","Builtin","bn","vars","lamAbsTerm","applyTerm","forceTerm","delayTerm","constant","constTerm","defaultFun","builtinTerm","errorTerm","DeBruijnedProgram","_this$version","major","minor","patch","FlatDeBruijnedProgram","v1","v2","v3","FlatTerm","ProgramFlatCodec","encoded","decoderState","getDeBruijnedProgram","deserializeContract","idx","contractByteArray","hexString","uint8Array","parseInt","substring","hexToUint8Array","uInt8Array","int8Array","toInt8Array","program","decodeFlat","namedTerm","go","env","_term$name","binderName","decodeFlatUplc","decodeFlatUplcToObject","applied","termPretty"],"sourceRoot":""}